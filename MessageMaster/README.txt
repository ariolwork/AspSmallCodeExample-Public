Задание для разработчика C#

Реализовать шлюз обработки сообщений в виде AspNetCore сервиса (единая точка)
- Вход: Message, который может содержать данные (пусть это будут текстовые данные для простоты) и дополнительную информацию типа идентификатора сообщения.
- Выход: Текстовый ответ на сообщение + метаданные
- Сервис определяет формат, вид сообщения и отдает на обработку соответствующему обработчику
- Обработчик обрабатывает сообщение конкретного вида и возвращает ответ
- Параметры обработчиков можно конфигурировать в конфигурационном файле
- Обработчики могут работать параллельно, степень параллельности задается в конфиге (для каждого может быть своя)
- Реализовать обработчик, который умеет переворачивать слова в тексте, например слово1 слово2 -> слово2 слово1
- Реализовать обработчик, который умеет считать количество слов
- Реализовать обработчик, который вычисляет сумму двух целых чисел
- Соответственно должна быть возможность легко добавлять новые обработчики

Вопросы на подумать:
- как реализовать асинхронную обработку (сервис принимает сообщение, отвечает, что принял, далее обрабатывает.) Как изменится API сервиса?
- обработка ошибок
- масштабирование




# Описание решения

## API
Так как у нас нет over разброса запросов, а все однотипные, избежим добавления маршрутизации и сопутствующей ей cosmic потерь. Сделаем собственную обработку сообщений.
Для начала добавим на самом низком уровне middleware для обработки ошибок.
Далее добавим свой обработчик HttpContext, который будет делать первичную валидацию запроса и передавать его на обработку в Application слой.(аналог Controller)
На этом уровне разбираем сообщение и передаем уже в конкретный сервит domain слоя.

## Domain
Опишем хэндлеры, реализующие абстрактный класс MessageHandlerBase, в который уже заложена логика конкурентности. Таким образом ссылкаемся на паттерн "шалонный метод".
Далее опишем класс, возвращающий нужный обраотчик, в зависимости от сообщения.
(используем подобие паттерна "строитель". Только не создаем каждый раз, а просто возвращаем из полей, куда они попадают при создании класса как синглтона(см. Register))
Такой подход позволит гибко работать с обработчиками.

### Что стоит добавить в решение но это уже займет больше времени чем хотелось бы
Когда приходят сообщения, регистрирвоать их в какой-то kv базе(либо локальном кэше), чтобы избежать повторной обработки из-за моргания сети
Добавление отложенной обработки через очередь сообщений или базу
Добавление задач с приоритетом.(Очевидно, что отложенная обработка ниже приоритетом, чем текущая). Реализуется чез союственный семафор(на основе interlocked либо TaskCompletionSource). Отличный доклад в котором можно понять точнее в ссылке 1.




# Вопросы

## как реализовать асинхронную обработку (сервис принимает сообщение, отвечает, что принял, далее обрабатывает.) Как изменится API сервиса?
Тут я вижу несколько подхоодов. Но любая такая обработка должна либо быть более низкого приоритета, чем обработка активных запросов, либо выполняться на отдельных нодах

### Первый и самый лучший
Не придумываем велосипед.
Регистрируем задачу в любой очереди сообщений и возвраащем success пользователю. Далее наш backService читает оттуда чообщения и обрабатывает их
Воркеры для работы с сообщениями kafks в том числе можно отделить от основных.
### Второй
Создаем табличку, заносим туда запросы и возвраащем success пользователю. Далее backService вынимает и обрабатывает их
При такой реализации при масштабировании мы не достигнем раномерного распределения и максимального быстродействия.
### Третий (может быть применен только как временный и с учетом рисков). Крайне не рекомендую к реализации, но в рамках МИКРОпроекта имеет право на жизнь
Создать ответственного со своей очередью внутри кода(SingleTone). Передавать такие запросы ему на обработку, а пользователю возвращать success.
При такой реализации одни минусы.

## обработка ошибок
Зависит от рода ошибки и реализации.
Если в запросе - просто логируем. Если в фоновой задаче, дополнительно можем ретраить какое то количество раз, затем положить в отдельный топик, либо таблицу в бд и разбирать вручную

## Масштабирование
Если сделать все верно. Использовать приоритеты для задач(или возможно поделить сервисы) и использовать распеределенный кэш(для фильтрации) для данной задачи масштабирование не будет какой то сложной задачей.
Остается только поднять какой-нибудь loadbalancer.
Из не важных доработок, еще перенес бы настройки воркеров в Environment Variables. Тогда будет сильно удобнее настраивать кластер.


#Ссылки
ссылка1 https://www.youtube.com/watch?time_continue=1355&v=-tNeYjRNJtY&embeds_euri=https%3A%2F%2Fhabr.com%2Fru%2Fcompanies%2Fjugru%2Farticles%2F468611%2F&feature=emb_logo&ab_channel=DotNext